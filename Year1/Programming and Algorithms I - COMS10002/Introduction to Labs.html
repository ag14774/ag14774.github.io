<p>This worksheet gives you a short list of commonly used Unix commands, please explore them by working out how to log in to a linux workstation, opening a command-line terminal, and using each of them in turn. This list is not intended to be complete, but to give a sample as a quick reference. You should find out more about the system by using the `man' command (see below), and by using the system routinely for your work.<p><b>Online Unix manual</b><p>To get information about any Unix command, you should use the <code>man</code> command: E.g.<ul><li> <code>man ls</code> gives information about how to use the <code>ls</code> commandThis command is only useful when you have an idea of what the command may be called in Unix. To quit without reading the entire manual page, press q.</ul><p><b>Seeing previous sessions</b><p>The shell records the commands that you enter. If you've found how to do something before and you want to see how to do it again you can access this history.<ul><li> <code>history</code> lists the previous commands with an index number<li> <code>!N</code> repeats commands with the index number <code>N</code><li> <code>!name</code> repeats the last command that started with name, e.g. <code>!ls</code> repeats the last <code>ls</code> command.<li> <code>!!</code> repeats the last command<li> <code>control-r</code> incrementally searches through the history backwards, e.g. <code>C-R fi</code> will find the previous command beginning with <code>fi</code></ul><p><b>Listing filenames</b><p>To list the contents of a directory (that is, to show the names of the files with other details like size, date created, protection, etc.) use the <code>ls</code> command.<ul>
<li> <code>ls</code> lists only the names of the files and directories<li> <code>ls -l</code> is the listing in long version showing protection etc.<li> <code>ls -s</code> shows the names and the sizes of the files and directories<li> <code>ls -a</code> shows all the files, including the dot files as well as the remaining files and directories<li> <code>ls *.sql</code> shows all the files ending with '.sql'. The '*' is called a 'wildcard' symbol, as expanded by the [Shell|linux command line interface].</ul><p><b>Copy</b><p>To copy a file from one filename to another use the cp command.<ul><li> <code>cp filename newfilename</code> copies the contents of <code>filename</code> to <code>newfilename</code><li> <code>cp *.tex directoryname</code> copies all files with the extension <code>.tex</code> into <code>directoryname</code><li> <code>cp -r directoryname otherdirectory</code> copies directory <code>directoryname</code> to <code>otherdirectory</code> recursively</ul><p><b>Rename (move)</b><p>To rename a file from one filename to another use the mv command.<ul><li> <code>mv filename newfilename</code> renames the file <code>filename</code> to <code>newfilename</code> </ul><p><b>Delete file</b><p>To delete (remove) a file use the rm command.<ul><li> <code>rm filename</code> deletes the file <code>filename</code> </ul><p>Note there is no command to undelete a file in Unix, when it is gone, it is gone...<p><b>Making and changing directories</b><p>To create a new directory use the mkdir command.<ul>
<li> <code>mkdir directoryname</code> creates a directory called <code>directoryname</code></ul><p>To change directories use the cd command.<ul><li> <code>cd ..</code> change to the directory above the current directory<li> <code>cd</code> (or <code>cd ~</code>) change to your own home directory<li> <code>cd directoryname</code> change to the directory called directoryname. </ul>
<p><b>File and directory protection</b><p>To change the protection of a file or directory use the chmod command.<ul><li> <code>chmod go+r</code> filename change the protection of filename to allow group and others read access<li> <code>chmod a+rx</code> directory change the protection of directory to allow group and others access </ul><p>The chmod (change mode) command changes the permissions on a file; it takes the changes to be made and the file name. The changes are "u" for you, "g" for your group, "o" for others or "a" for all (=ugo) followed by a "+" to add permissions or a "-" to remove them, followed by "r" for read permission (needed for web files) or "w" for write permission or "x" for execute permission (also needed along with "r" for public access directories leading to web files).<p>There is much more to this command. Use the man command if in doubt.<p><b>Process commands</b><p>To see what processes are running use the ps command.<ul><li> <code>ps</code> </ul><p>To kill a process use the kill command.<ul><li> <code>kill -KILL process_id</code> kills the process process_id, the process_id is shown after the ps command </ul><p><b>Disk quotas</b><p>To see how much disk space you have used and what is left use the quota command.<ul><li> <code>quota -v</code> </ul><p><b>Displaying file contents</b><p>To display the contents of a text file (without editing it) use the `less' command.<ul><li> <code>less filename</code>displays the contents of filename, one screenful at a time. Type <SPACE> to get the next screenful, or q to quit. Arrow keys take you through the file one line at a time, G sends you to the end. '/string' searches for string. (If you're wondering, `more' was the original, then an enhanced version called `less' was produced -- remember `less is more'.)</ul><p><b>Finding things</b><p>An invaluable tool is `grep', this can search text files for specific strings or patterns, and print out each line which contains a match.<ul><li> <code>grep FIXME *.{h,c} </code>will find all the places in my .h and .cc files where I've reminded myself to fix something. The pattern which grep uses is called a regular expression or regexp for short. It's easier to read the manual page for grep and regexp, than repeat it all here, needless to say, regexps can be very powerful. (Note, regexps are related to, but differ from, shell globs, they share some common features.)<li> <code>find DIR -name 'NAME'</code>will search for files that match the pattern <code>NAME</code>. This can be a simple filename or a regexp. The quotes around the pattern prevent the shell from interpreting the characters in the regexp, allowing <code>find</code> to see them. The search will start in the directory <code>DIR</code> and recursively scan any subdirectories to check for a match.<li> <code>locate NAME</code>will search some system locations for a file that contains the string <code>NAME</code>. If you want to search the system directories which are mounted over NFS this will usually be quicker than using <code>find</code>. <code>locate</code> only works on predefined directories so if you want to search within your own home directories then <code>find</code> must be used.
</ul>
<p><b>Simple programs</b><p>In order to compile a C program under Linux you must first create the C program and store it in a file with a name that ends with `.c'. Once you have made this file, say, test.c you can compile this with the following command:<p><code>gcc test.c -o myprogram</code><p>gcc is the GNU-c-compiler, a public domain C compiler that we use. It will read the file test.c, and produce a file <code>myprogram</code> which you can execute. If you do not supply '<code>-o myprogram</code>' then the default output name is <code>a.out</code>. A common mistake is to call the output file <code>test</code>. <code>test</code> is the name of a shell command which will be executed instead of the program giving no results. To execute the compiled program just type:<p><code>myprogram</code><p><b>Programs stored in multiple files</b><p>In order to compile a C program which is stored in multiple files (all ending with a `.c' suffix), you will need to call the compiler several items; once for each module, and once to link the modules together (you can automate this process). Say that your modules are stored in files module.c, test.c and main.c, you would compile this with:<p><code>gcc -c module.c<br>gcc -c test.c<br>gcc -c main.c<br>gcc -o mainprog module.o test.o main.o</code></p><p>The first command compiles the file module.c, the option -c instruct the compiler to compile only, and not to create a final program. It will create a file called module.o, where the .o stands for object-code. The second and the third command compile the modules test.c and main.c into test.o and main.o. Finally, the last command uses the C compiler to read the object files module.o, test.o and main.o and link them into a final executable called mainprog.<p>If you change one of the source file, you only need to recompile that module, and link all modules together again. So, say you have changed main.c, then the following command will create a new version:<p><code>gcc -c main.c<br>gcc -o mainprog module.o test.o main.o</code><p><b>Options</b><ul><li> If you want your program to run faster type <code>gcc -O2 test.c -o myprogram</code>, <code>-O2</code> will cause the compiler to optimise the generated code. You can combine <code>-O2</code> with <code>-c</code>, eg, <code>gcc -c -O2 module.c</code>.<li> If you need mathematical functions in your program (sine, cosine, sqrt), type <code>gcc test.c -o myprogram -lm</code>, the <code>-lm</code> will cause the linker to include the library of mathematical functions. When compiling mulitple source files, specify the <code>-lm</code> option with the last command that links all object modules together: <code>gcc -o mainprog module.o test.o main.o -lm</code><li> If you want to enable the debugger, type <code>gcc -g test.c -o myprogram</code>, <code>-g</code> will cause the compiler to generated code that is suitable for the debugger.<li> The <code>-o</code> flag specifies what name the final program will have.<li> The <code>-Wall</code> flag will cause the compiler to warn you about possible errors</li><li>In general it is a good idea to use compiler flags that ensure maximum compatibility of your code to C standards, and all warnings as well as errors reported. You can use <code>-ansi</code>, <code>-std=c99</code> or <code>-std=c11</code> to ensure compatibility with different versions of C (we will typically use c99). The <code>-pedantic</code> flag ensures strict adherence to the ansi standard if required.</li>
</ul>
<p>You can use a Makefile if you want to compile a program more than once. See if you can explore online how to do this.
<p><b>C Reference</b><p><a href="http://en.wikipedia.org/wiki/C_standard_library">http://en.wikipedia.org/wiki/C_standard_library</a><p>The standard C library contains 24 header files which you can include into your program with the directive:<p><code>#include <header_file_name.h></code><p>The official (and most complete) library manual for GCC can be found here:<br><a href="http://www.gnu.org/software/libc/manual/">http://www.gnu.org/software/libc/manual/</a>.