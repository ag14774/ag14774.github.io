#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass report
\begin_preamble

\newcount\colveccount
\newcommand*\colvec[1]{
        \global\colveccount#1
        \begin{pmatrix}
        \colvecnext
}
\def\colvecnext#1{
        #1
        \global\advance\colveccount-1
        \ifnum\colveccount>0
                \\
                \expandafter\colvecnext
        \else
                \end{pmatrix}
        \fi
}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{Andreas Georgiou - ag14774}
\rhead{\thepage}
\cfoot{}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\usepackage{esdiff}
\usepackage{graphicx}
\usepackage{amsfonts}\author{Andreas Georgiou - ag14774}
\title{Coursework 1\\ Data Structures and Algorithms}
\usepackage[capposition=top]{floatrow}
\end_preamble
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package none
\inputencoding utf8
\fontencoding default
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry true
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 3cm
\topmargin 2cm
\rightmargin 3cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset

 
\end_layout

\begin_layout Paragraph*
Question 2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part a
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $P\left[i,x\right]$
\end_inset

 to be the maximum profit that can be obtained if you only run the shop
 for the first 
\begin_inset Formula $i$
\end_inset

 day(s) and you start the 
\begin_inset Formula $i$
\end_inset

-th day with item 
\begin_inset Formula $x$
\end_inset

 in stock.
 
\begin_inset Formula $U\left[i\right]$
\end_inset

 is defined to be the profit you will make on the 
\begin_inset Formula $i$
\end_inset

-th day if you have umbrellas in stock and 
\begin_inset Formula $S\left[i\right]$
\end_inset

 is defined to be the profit you will make on the 
\begin_inset Formula $i$
\end_inset

-th day if you have suncream in stock.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Define 
\begin_inset Formula $X_{x}\left[i\right]$
\end_inset

 as a function that returns the profit of the shop on the 
\begin_inset Formula $i$
\end_inset

-th day with stock 
\begin_inset Formula $x$
\end_inset

:
\begin_inset Formula 
\[
X_{x}\left[i\right]=\begin{cases}
U\left[i\right] & x=u\\
S\left[i\right] & x=s
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
Define 
\begin_inset Formula $t(x)$
\end_inset

 as a function that toggles 
\begin_inset Formula $x$
\end_inset

 between umbrellas(
\begin_inset Formula $u$
\end_inset

) and suncream(
\begin_inset Formula $s$
\end_inset

).
 Formally:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
t\left(x\right)=\begin{cases}
u & x=s\\
s & x=u
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
The recursive formula is formally defined as (where 
\begin_inset Formula $m$
\end_inset

 is the cost of switching between products):
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
P\left[i,x\right]=\begin{cases}
X_{x}\left[i\right] & i=1\\
X_{x}\left[i\right]+max\begin{cases}
P\left[i-1,x\right]\\
P[i-1,t\left(x\right)-m
\end{cases} & otherwise
\end{cases}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part b
\end_layout

\begin_layout Standard
Consider the solution of 
\begin_inset Formula $P\left[i,x\right]$
\end_inset

.
 During day 
\begin_inset Formula $i$
\end_inset

 the shop will make 
\begin_inset Formula $X_{x}\left[i\right]$
\end_inset

 profit.
 During the previous day (
\begin_inset Formula $i-1$
\end_inset

) the shop either sold the same product 
\begin_inset Formula $x$
\end_inset

 as day 
\begin_inset Formula $i$
\end_inset

 or product 
\begin_inset Formula $t(x)$
\end_inset

.
\end_layout

\begin_layout Standard
In the first case, since the shop sold the same product, it did not incur
 any costs going from day 
\begin_inset Formula $i-1$
\end_inset

 to day 
\begin_inset Formula $i$
\end_inset

.
 Therefore the total profit for the first 
\begin_inset Formula $i$
\end_inset

 days will be the sum of the profit made on day 
\begin_inset Formula $i$
\end_inset

 and the profit made during the first 
\begin_inset Formula $i-1$
\end_inset

 days, where the product sold during day 
\begin_inset Formula $i-1$
\end_inset

 was 
\begin_inset Formula $x$
\end_inset

.
\end_layout

\begin_layout Standard
Alternatively, the shop sold a different product on day 
\begin_inset Formula $i-1$
\end_inset

.
 In this case, the switching cost the shop 
\begin_inset Formula $m$
\end_inset

 pounds.
 The total profit here, is the sum of the profit made on day 
\begin_inset Formula $i$
\end_inset

 and the profit made during the first 
\begin_inset Formula $i-1$
\end_inset

 days, where the product sold during day 
\begin_inset Formula $i-1$
\end_inset

 was 
\begin_inset Formula $t\left(x\right)$
\end_inset

 minus the cost 
\begin_inset Formula $m$
\end_inset

 of going from day 
\begin_inset Formula $i-1$
\end_inset

 to day 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Standard
Finally, the shop can sell either umbrellas or suncream during the last
 day 
\begin_inset Formula $n$
\end_inset

.
 Therefore the solution to the problem is 
\begin_inset Formula $max\{P\left[n,u\right],P\left[n,s\right]\}$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part f
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(0)void cornershopI(){
\end_layout

\begin_layout Plain Layout

(1)	for(int i=0;i<n;i++){
\end_layout

\begin_layout Plain Layout

(2)		for(int j=0;j<2;j++){
\end_layout

\begin_layout Plain Layout

(3)			if(i==0)
\end_layout

\begin_layout Plain Layout

(4)				mem[j][i] = input[j][i];
\end_layout

\begin_layout Plain Layout

(5)			else
\end_layout

\begin_layout Plain Layout

(6)				mem[j][i] = Math.max(mem[j][i-1], mem[j^1][i-1]-m) + input[j][i];
\end_layout

\begin_layout Plain Layout

(7)		}
\end_layout

\begin_layout Plain Layout

(8)	}
\end_layout

\begin_layout Plain Layout

(9)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of the above algorithm is 
\begin_inset Formula $\varTheta\left(n\right)$
\end_inset

.
 The array 
\begin_inset Formula $mem[j][i]$
\end_inset

 holds the result of 
\begin_inset Formula $P\left[i,j\right]$
\end_inset

 where 
\begin_inset Formula $j=0$
\end_inset

 represents 
\begin_inset Formula $u$
\end_inset

 and 
\begin_inset Formula $j=1$
\end_inset

 represents 
\begin_inset Formula $s$
\end_inset

.
 The inner for-loop(2) is only executed twice and therefore takes constant
 time.
 The time complexity of lines (3)-(6) is constant since the max operation
 also takes constant time.
 The function 
\begin_inset Formula $t(x)$
\end_inset

 here is implemented as a XOR bitwise operation on 
\begin_inset Formula $j$
\end_inset

.
 The total time complexity is only determined by the outer for-loop(1) which
 is executed 
\begin_inset Formula $n$
\end_inset

 times\SpecialChar \@.

\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T(n)=\sum2_{i=1}^{n}=2n=\varTheta(n)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph*
Question 3
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Part a
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $v$
\end_inset

 be the magician at the root of the tree(with 
\begin_inset Formula $id=0$
\end_inset

).
 For each magician we define the following attributes/methods:
\end_layout

\begin_layout Itemize
\begin_inset Formula $v.ability$
\end_inset

 : The ability of magician 
\begin_inset Formula $v$
\end_inset

.
\end_layout

\begin_layout Itemize
\begin_inset Formula $v.children$
\end_inset

 : Returns a set with all the apprentices of magician 
\begin_inset Formula $v$
\end_inset

.
 (i.e.
 all nodes that are directly below of 
\begin_inset Formula $v$
\end_inset

 in the tree hierarchy.)
\end_layout

\begin_layout Itemize
\begin_inset Formula $v.grandchildren$
\end_inset

 : Returns a set with all the apprentices of all the apprentices of magician
 
\begin_inset Formula $v$
\end_inset

 (i.e.
 those that are 2 levels below of v in the tree hierarchy.)
\end_layout

\begin_layout Standard
Formally the recursive formula is:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
magic(v)=max\begin{cases}
\left[\sum_{\forall x\in v.grandchildren}magic\left(x\right)\right]+v.ability\\
\sum_{\forall x\in v.children}magic\left(x\right)
\end{cases}
\]

\end_inset

The above formula can be simplified by adding two additional attributes:
\end_layout

\begin_layout Itemize
\begin_inset Formula $v.includeMe$
\end_inset

 : This stores the best magical ability if we include 
\begin_inset Formula $v$
\end_inset

 in our solution.
 Initially set to 
\begin_inset Formula $v.ability$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $v.excludeMe$
\end_inset

 : This stores the best magical ability if we exclude 
\begin_inset Formula $v$
\end_inset

 in our solution.
 Initially set to 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
Then the formula can be broken into smaller sub-formulas:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v.excludeMe=\begin{cases}
0 & v.children=\emptyset\\
v.excludeMe+magic\left(x\right) & \forall x\in v.children
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
v.includeMe=\begin{cases}
v.ability & v.children=\emptyset\\
v.ability+v.includeMe+x.excludeMe & \forall x\in v.children
\end{cases}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
magic(v)=max\begin{cases}
v.excludeMe\\
v.includeMe
\end{cases}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part b
\end_layout

\begin_layout Standard
The problem of 
\begin_inset Formula $magic(v)$
\end_inset

 can be thought of as having only two cases.
 The first case is when node 
\begin_inset Formula $v$
\end_inset

 itself will be included in the optimal set.
 Because of that, we skip the children directly below of 
\begin_inset Formula $v$
\end_inset

 and we add to the total ability of the tree with root 
\begin_inset Formula $v$
\end_inset

 the maximum ability 
\begin_inset Formula $magic(x)$
\end_inset

 for each one of its grandchildren 
\begin_inset Formula $x$
\end_inset

.
 This is only possible because of the fact that there are no cycles in the
 graph (i.e.
 there are no nodes in the same level directly connected with one another).
\end_layout

\begin_layout Standard
The second case is when node 
\begin_inset Formula $v$
\end_inset

 is excluded from the optimal set.
 The total ability of the tree with root 
\begin_inset Formula $v$
\end_inset

 will be the same as the sum of the magic abilities 
\begin_inset Formula $magic(x)$
\end_inset

 of each child 
\begin_inset Formula $x\in v.children$
\end_inset

.
\end_layout

\begin_layout Standard
The MAGIC-TOURNAMENT problem is similar to the problem of Weighted Scheduling
 Interval in the sense that we are trying to find compatible magicians.
 In the WIS problem, a function 
\begin_inset Formula $p(i)$
\end_inset

 returns the next compatible interval assuming that 
\begin_inset Formula $i$
\end_inset

 will be in the optimal set.
 However, in this case we already know that the next compatible magician
 will be the set of all its grandchildren.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part d
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{The solution was inspired by Jeff Erickson's Maximum Independent
 Set algorithm.}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(0)int magicTournament(Magician root){
\end_layout

\begin_layout Plain Layout

(1)	root.includingMe = root.ability;
\end_layout

\begin_layout Plain Layout

(2)	root.excludingMe = 0;
\end_layout

\begin_layout Plain Layout

(3)	Iterator<Magician> it = root.getChildrenIterator();
\end_layout

\begin_layout Plain Layout

(4)	while(it.hasNext()){
\end_layout

\begin_layout Plain Layout

(5)		Magician child = it.next();
\end_layout

\begin_layout Plain Layout

(6)		root.excludingMe += magicTournament(child);
\end_layout

\begin_layout Plain Layout

(7)		root.includingMe += child.excludingMe;
\end_layout

\begin_layout Plain Layout

(8)	}
\end_layout

\begin_layout Plain Layout

(9)	return Math.max(root.includingMe, root.excludingMe);
\end_layout

\begin_layout Plain Layout

(10)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of the above algorithm is 
\begin_inset Formula $\varTheta\left(n\right)$
\end_inset

.
 We are visiting each node only once in a depth first manner as shown in
 the picture below.
 For a node 
\begin_inset Formula $v$
\end_inset

, the while loop(4) is only executed 
\begin_inset Formula $k$
\end_inset

 times where 
\begin_inset Formula $k=v.children<n$
\end_inset

.
 The total amount of times the loop is executed after the algorithm has
 finished running, will be 
\begin_inset Formula $n-1$
\end_inset

 which is equal to the edges of the tree.
\end_layout

\begin_layout Standard
The algorithm shown here, is memoized because of the fact that we are storing
 the results in the tree itself.
 We are storing two values for each node: the value of the maximum ability
 that includes that node and the value of the maximum ability that excludes
 the root.
 This algorithm benefits from memoization, because in line (7) we are reusing
 the results calculated in the recursion call in line (6).
 Specifically, 
\begin_inset Formula $child.excludingMe$
\end_inset

 will already be calculated by the time that line gets executed because
 
\begin_inset Formula $child$
\end_inset

 was recursively passed as a parameter to the function during the execution
 of the previous line.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
begin{minipage}{0.4
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.65]{magiciantreetraveral}
\end_layout

\begin_layout Plain Layout

{
\backslash
footnotesize 
\backslash
newline The tree is traversed in a depth first manner
\backslash
par}
\end_layout

\begin_layout Plain Layout


\backslash
end{minipage}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Paragraph*
Question 4
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard

\series bold
Part a
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $D\left[i,j\right]$
\end_inset

 be the maximum profit possible if you work only for the last 
\begin_inset Formula $i$
\end_inset

 days(from day 
\begin_inset Formula $i$
\end_inset

 to day 
\begin_inset Formula $n$
\end_inset

) and the last day-off was 
\begin_inset Formula $j$
\end_inset

 days ago.
 Then the recursive formula is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
D\left[i,j\right]=\begin{cases}
min\left\{ B\left[i\right],M\left[j\right]\right\}  & i=n\\
max\begin{cases}
min\left\{ B\left[i\right],M\left[j\right]\right\} +D\left[i+1,j+1\right]\\
D[i+1,1]
\end{cases} & otherwise
\end{cases}
\]

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part b
\end_layout

\begin_layout Standard
The problem consists of two cases.
 The first case, which is also the case when the recursion stops, is when
 you take into account only the last day of work(i.e.
 day 
\begin_inset Formula $n$
\end_inset

).
 Since there is no profit in taking the last day off, you can either deliver
 the maximum amount of sandwiches as allowed by regulations based on the
 last day off you have taken or deliver all orders for day 
\begin_inset Formula $i$
\end_inset

 if the number of orders is within the allowance(i.e.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $min\left\{ B\left[i\right],M\left[j\right]\right\} $
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
).
\end_layout

\begin_layout Standard
Lastly, the second case consists of two subcases, of which we want to choose
 the one that returns the most profits.
 The first subcase is that you work during that day and sell the maximum
 amount of sandwiches as allowed by law and the second is that you take
 that day off.
 In the first one, the profits would be equal to the amount of sandwiches
 sold during day 
\begin_inset Formula $i$
\end_inset

(always taking the minimum of 
\begin_inset Formula $B[i]$
\end_inset

 and 
\begin_inset Formula $M[j]$
\end_inset

 to make sure that no regulations are violated) plus the maximum amount
 of sandwiches sold during the days 
\begin_inset Formula $i+1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

.
 The second subcase, since you take that day off, no sandwiches will be
 delivered, but the allowance can be reset.
 That is the profits in this case would be equal to the maximum amount of
 sandwiches sold during the day 
\begin_inset Formula $i+1$
\end_inset

 to 
\begin_inset Formula $n$
\end_inset

(taking into account the new allowance i.e.
 resetting the index of the array 
\begin_inset Formula $M[j]$
\end_inset

 back to 1).
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part c
\end_layout

\begin_layout Standard
The recursive formula directly outputs the correct solution to the Day-Off
 problem.
 Since we want the result taking into account all days and initially we
 have taken the previous day before taking control of the deliveries off,
 we start with 
\begin_inset Formula $D\left[1,1\right]$
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part f
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[scale=0.3]{p4mem}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of the memoized algorithm is 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
 As we see in the table above, at worst, half of the array would have to
 be filled.
 That is, an isosceles triangle with side length 
\begin_inset Formula $n$
\end_inset

.
 Total cells are equal to 
\begin_inset Formula $\frac{n^{2}}{2}$
\end_inset

.
 Each cell in the picture chooses the maximum between the value pointed
 by the left arrow, and the value pointed by the right arrow plus 
\begin_inset Formula $min\left\{ B\left[i\right],M\left[j\right]\right\} $
\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\series bold
Part h
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

(0)int dayOffI(){
\end_layout

\begin_layout Plain Layout

(1)	for(int i=n-1;i>=0;i--){
\end_layout

\begin_layout Plain Layout

(2)		for(int j=0;j<=i;j++){
\end_layout

\begin_layout Plain Layout

(3)			if(i==n-1)
\end_layout

\begin_layout Plain Layout

(4)				mem[i][j] = Math.min(input[0][i],input[1][j]);
\end_layout

\begin_layout Plain Layout

(5)			else
\end_layout

\begin_layout Plain Layout

(6)				mem[i][j] = Math.max(Math.min(input[0][i],input[1][j])+mem[i+1][j+1],
 mem[i+1][0]);
\end_layout

\begin_layout Plain Layout

(7)		}
\end_layout

\begin_layout Plain Layout

(8)	}
\end_layout

\begin_layout Plain Layout

(9)	return mem[0][0];
\end_layout

\begin_layout Plain Layout

(10)}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The time complexity of the iterative algorithm is 
\begin_inset Formula $\varTheta\left(n^{2}\right)$
\end_inset

.
 Here the two arrays 
\begin_inset Formula $B[i]$
\end_inset

 and 
\begin_inset Formula $M[j]$
\end_inset

 are combined in a single array called 
\begin_inset Formula $input$
\end_inset

.
 All lines will be executed in constant time 
\begin_inset Formula $\varTheta\left(1\right)$
\end_inset

 except the two for-loops in lines (1) and (2).
 As it is shown in the picture in the previous part, we can see that the
 triangle has to be filled from the bottom up to satisfy all the dependencies.
 Specifically, the inner loop will be executed 
\begin_inset Formula $n+(n-1)+\ldots+1$
\end_inset

 times:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T\left(n\right)=1+2+...+n
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T\left(n\right)=\sum_{i=1}^{n}i=\frac{n(n+1)}{2}=\frac{n^{2}}{2}+\frac{n}{2}=\Theta\left(n^{2}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
It might be possible to improve the time complexity to 
\begin_inset Formula $\varTheta\left(n\log n\right)$
\end_inset

 using the fact that the array 
\begin_inset Formula $M\left[j\right]$
\end_inset

 is sorted with 
\begin_inset Formula $M\left[j\right]\leq M\left[j-1\right]$
\end_inset

 for all 
\begin_inset Formula $j$
\end_inset

.
\end_layout

\end_body
\end_document
