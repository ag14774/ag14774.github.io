// COMS22201: Code generation

import java.util.*;
import java.io.*;
import java.lang.reflect.Array;

public class Cg {
    static int                       registerCount = 1;
    static ArrayList<Instruction>    instructions  = new ArrayList<Instruction>();
    private static Set<String> labelsUsed    = new HashSet<String>();

    public static ArrayList<Instruction> program(IRTree irt) {
        clearRegister("R0"); // Initialize R0 to 0
        statement(irt);
        halt(); // Program must end with HALT
        return instructions;
        // Memory.dumpData(o); // Dump DATA lines: initial memory contents
    }

    private static void clearRegister(String register) {
        emit("XOR " + register + "," + register + "," + register);
    }

    private static void halt() {
        emit("HALT");
    }

    private static void statement(IRTree irt) {
        if (irt.getOp().equals("SEQ")) {
            statement(irt.getSub(0));
            statement(irt.getSub(1));
        } else if (irt.getOp().equals("WRS") && irt.getSub(0).getOp().equals("MEM") && irt.getSub(0).getSub(0).getOp().equals("CONST")) {
            String a = irt.getSub(0).getSub(0).getSub(0).getOp();
            emit("WRS " + a);
        } else if (irt.getOp().equals("WR")) {
            String e = expression(irt.getSub(0), false);
            emit("WR " + e);
        } else if (irt.getOp().equals("MOVE")) {
            String e = rightMove(irt.getSub(1));
            String offset = irt.getSub(0).getSub(0).getSub(0).getOp();
            emit("STORE " + e + ",R0," + offset);
        } else if (irt.getOp().equals("CJUMP")) {
            String instr = irt.getSub(0).getOp();
            //TRY EVALUATE EXPRESSIONS AT COMPILATION TIME
            String e1 = expression(irt.getSub(1), true);
            String e2;
            if (!e1.startsWith("R")) {
                e2 = expression(irt.getSub(2), true);
                if (e2.startsWith("R"))
                    e1 = expression(irt.getSub(1), false);
            } else {
                e2 = expression(irt.getSub(2), false);
            }
            if (!e1.startsWith("R") && !e2.startsWith("R")){
                evaluateTrivialCJUMP(instr, e1, e2, irt.getSub(3).getSub(0).getOp(), irt.getSub(4).getSub(0).getOp());
            }
            else {
                boolean labelNext = followedByLabel(irt);
                if (labelNext) {
                    boolean falseNext = followedByFalseLabel(irt);
                    if (!falseNext)
                        instr = reverseOp(instr);
                    String expr = subtractCJUMP(e1, e2, instr);
                    emitConditional(irt, expr, instr, !falseNext);
                } else {
                    String expr = subtractCJUMP(e1, e2, instr);
                    emitConditional(irt, expr, instr, false);
                    String falseLabel = irt.getSub(4).getSub(0).getOp();
                    emit("JMP " + falseLabel);
                    labelsUsed.add(falseLabel);
                }
            }
        } else if (irt.getOp().equals("LABEL")) {
            String label = irt.getSub(0).getOp();
            emit(label + ": ");
        } else if (irt.getOp().equals("JUMP")) {
            boolean labelFollows = followedByLabel(irt);
            if (!labelFollows) {
                String label = irt.getSub(0).getSub(0).getOp();
                emit("JMP " + label);
                labelsUsed.add(label);
            }
        } else if (irt.getOp().equals("SKIP")) {
            emit("NOP");
        } else {
            error(irt.getOp());
        }
    }

    private static void emitConditional(IRTree irt, String exprRegister, String op, boolean useFalse) {
        String label;
        if (useFalse)
            label = irt.getSub(4).getSub(0).getOp();
        else
            label = irt.getSub(3).getSub(0).getOp();
        switch (op) {
        case "<=":
            emit("BGEZ " + exprRegister + "," + label);
            break;
        case "<":
            emit("BLTZ " + exprRegister + "," + label);
            break;
        case ">=":
            emit("BGEZ " + exprRegister + "," + label);
            break;
        case ">":
            emit("BLTZ " + exprRegister + "," + label);
            break;
        case "=":
            emit("BEQZ " + exprRegister + "," + label);
            break;
        case "!=":
            emit("BNEZ " + exprRegister + "," + label);
            break;
        }
        labelsUsed.add(label);
    }
    
    private static void evaluateTrivialCJUMP(String instr, String e1, String e2){
        boolean result = false;
        switch (instr) {
        case "<=":
            if(Integer.parseInt(e1) <= Integer.parseInt(e2))
                result = true;
            break;
        case "<":
            if(Integer.parseInt(e1) < Integer.parseInt(e2))
                result = true;
            break;
        case ">=":
            if(Integer.parseInt(e1) >= Integer.parseInt(e2))
                result = true;
            break;
        case ">":
            if(Integer.parseInt(e1) > Integer.parseInt(e2))
                result = true;
            break;
        case "=":
            if(Integer.parseInt(e1) == Integer.parseInt(e2))
                result = true;
            break;
        case "!=":
            if(Integer.parseInt(e1) != Integer.parseInt(e2))
                result = true;
            break;
        }
        return result;
    }

    private static String reverseOp(String op) {
        switch (op) {
        case "<=":
            return ">";
        case "<":
            return ">=";
        case ">=":
            return "<";
        case ">":
            return "<=";
        case "=":
            return "!=";
        case "!=":
            return "=";
        default:
            return op;
        }
    }

    private static boolean followedByLabel(IRTree irt) {
        if (irt.getOp().equals("CJUMP")) {
            String label1 = irt.getSub(3).getSub(0).getOp();
            String label2 = irt.getSub(4).getSub(0).getOp();
            IRTree next = irt.findNextInstruction();
            if (next != null && next.getOp().equals("LABEL")) {
                if (next.getSub(0).getOp().equals(label1) || next.getSub(0).getOp().equals(label2))
                    return true;
            }
        } else if (irt.getOp().equals("JUMP")) {
            String label = irt.getSub(0).getSub(0).getOp();
            IRTree next = irt.findNextInstruction();
            if (next != null && next.getOp().equals("LABEL")) {
                if (next.getSub(0).getOp().equals(label))
                    return true;
            }
        }
        return false;
    }

    private static boolean followedByFalseLabel(IRTree irt) {
        if (irt.getOp().equals("CJUMP")) {
            String label1 = irt.getSub(4).getSub(0).getOp();
            IRTree next = irt.findNextInstruction();
            if (next != null && next.getOp().equals("LABEL")) {
                if (next.getSub(0).getOp().equals(label1))
                    return true;
            }
        }
        return false;
    }

    private static String subtractCJUMP(String e1, String e2, String instr) {
        String result = "";
        result = getNewRegister();
        if (instr.equals(">=") || instr.equals("<") || instr.equals("=") || instr.equals("!="))
            emit("SUB " + result + "," + e1 + "," + e2);
        else
            emit("SUB " + result + "," + e2 + "," + e1);
        return result;
    }

    private static String rightMove(IRTree irt) {
        if (irt.getOp().equals("READ")) {
            return read(irt);
        } else {
            return expression(irt, false);
        }
    }

    private static String read(IRTree irt) {
        String result = "";
        if (irt.getOp().equals("READ")) {
            result = getNewRegister();
            emit("RD " + result);
        }
        return result;
    }

    private static String expression(IRTree irt, boolean returnValue) {
        String result = "";
        if (irt.getOp().equals("CONST")) {
            String t = irt.getSub(0).getOp();
            if (returnValue)
                result = t;
            else {
                result = getNewRegister();
                emit("ADDI " + result + ",R0," + t);
            }
        } else if (irt.getOp().equals("MEM")) {
            String offset = expression(irt.getSub(0), true);
            result = getNewRegister();
            if (offset.startsWith("R")) {
                emit("LOAD " + result + "," + offset + ",0");
            } else {
                emit("LOAD " + result + ",R0," + offset);
            }
        } else if (irt.getOp().equals("BINOP")) {
            result = arithmetic(irt);
            if (!result.startsWith("R") && !returnValue) {
                String tmp = result;
                result = getNewRegister();
                emit("ADDI " + result + ",R0," + tmp);
            }
        } else {
            error(irt.getOp());
        }
        return result;
    }

    private static String arithmetic(IRTree irt) {
        String result = "";
        if (irt.getOp().equals("BINOP")) {
            String op = irt.getSub(0).getOp();
            String instr = "";
            if (op.equals("+")) {
                instr = "ADD";
            } else if (op.equals("-")) {
                instr = "SUB";
            } else if (op.equals("*")) {
                instr = "MUL";
            }
            String res1 = expression(irt.getSub(1), true);
            String res2;
            if (!res1.startsWith("R")) {
                res2 = expression(irt.getSub(2), true);
                if (res2.startsWith("R"))
                    res1 = expression(irt.getSub(1), false);
            } else {
                res2 = expression(irt.getSub(2), false);
            }
            if (!res1.startsWith("R") && !res2.startsWith("R")) {
                if (instr.equals("ADD"))
                    result = String.valueOf(Integer.parseInt(res1) + Integer.parseInt(res2));
                else if (instr.equals("SUB"))
                    result = String.valueOf(Integer.parseInt(res1) - Integer.parseInt(res2));
                else if (instr.equals("MUL"))
                    result = String.valueOf(Integer.parseInt(res1) * Integer.parseInt(res2));
            } else {
                result = getNewRegister();
                emit(instr + " " + result + "," + res1 + "," + res2);
            }
        } else {
            error(irt.getOp());
        }
        return result;
    }

    private static void emit(String s) {
        instructions.add(Instruction.toInstruction(s));
    }

    private static void error(String op) {
        System.out.println("CG error: " + op);
        System.exit(1);
    }

    public static Set<String> getLabelsUsed() {
        return labelsUsed;
    }

    private static String getNewRegister() {
        String res = "R" + registerCount;
        registerCount++;
        return res;
    }

}
