import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Set;

public class CleanUp {

    public static boolean advancedDeadCodeRemovalEnabled = false;
    
    public
    
    public static boolean removeDeadCodeOnePass(ArrayList<Instruction> instructions) {
        boolean result = false;
        boolean removeJumpToo = false;
        LabelCleanUp(instructions);
        ListIterator<Instruction> it = instructions.listIterator(0);
        System.out.println("pass");
        while (it.hasNext()) {
            Instruction temp = it.next();
            if (temp.opcode.equals("JMP")) {
                String jumpLabel = temp.op1;
                ListIterator<Instruction> inner = instructions.listIterator(it.nextIndex());
                while (inner.hasNext()) {
                    Instruction check = inner.next();
                    if (check.getLabel().equals("") && !check.opcode.equals("HALT")) {
                        inner.remove();
                        result = true;
                    } else {
                        if (check.getLabel().equals(jumpLabel)) {
                            removeJumpToo = advancedRemovalEnabled;
                        }
                        break;
                    }
                }
                if(removeJumpToo){
                    int index = inner.nextIndex()-2;
                    if(index<0)
                        index = 0;
                    it = instructions.listIterator(index);
                    if(it.hasNext()){
                        it.next();
                        it.remove();
                        result = true;
                    }
                }else{
                    it = inner;
                }
            }
        }
        return result;
    }

    public static void removeDeadCode(ArrayList<Instruction> instructions) {
        while (removeDeadCodeOnePass(instructions))
            ;
    }

    public static void LabelCleanUp(ArrayList<Instruction> instructions) {
        Set<String> labelsUsed = analyseLabelUsage(instructions);
        Iterator<Instruction> it = instructions.iterator();
        while (it.hasNext()) {
            Instruction temp = it.next();
            if (!temp.getLabel().equals("") && !labelsUsed.contains(temp.getLabel())) {
                temp.setLabel("");
                if (temp.opcode.equals(""))
                    it.remove();
            }
        }
    }

    public static Set<String> analyseLabelUsage(ArrayList<Instruction> instructions) {
        Set<String> labelsUsed = new HashSet<String>();
        for (Instruction in : instructions) {
            switch (in.opcode) {
            case "JMP":
                labelsUsed.add(in.op1);
                break;
            case "IADDR":
                labelsUsed.add(in.op2);
                break;
            case "BGEZ":
                labelsUsed.add(in.op2);
                break;
            case "BGEZR":
                labelsUsed.add(in.op2);
                break;
            case "BLTZ":
                labelsUsed.add(in.op2);
                break;
            case "BLTZR":
                labelsUsed.add(in.op2);
                break;
            case "BEQZ":
                labelsUsed.add(in.op2);
                break;
            case "BEQZR":
                labelsUsed.add(in.op2);
                break;
            case "BNEZ":
                labelsUsed.add(in.op2);
                break;
            case "BNEZR":
                labelsUsed.add(in.op2);
                break;
            }
        }
        return labelsUsed;
    }

}
