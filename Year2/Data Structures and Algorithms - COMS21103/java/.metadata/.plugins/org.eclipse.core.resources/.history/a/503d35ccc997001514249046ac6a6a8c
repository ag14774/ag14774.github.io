// $ANTLR 3.5.2 Syn.g 2015-12-01 01:19:55

    import java.util.HashSet;
    import java.util.Set;


import org.antlr.runtime.*;
import java.util.Stack;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

import org.antlr.runtime.tree.*;


@SuppressWarnings("all")
public class Syn extends Parser {
	public static final String[] tokenNames = new String[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ADD", "AND", "ASSIGN", "CLOSEPAREN", 
		"COMMENT", "DEF", "DIGIT", "DO", "ELSE", "EQ", "FALSE", "ID", "IF", "INTNUM", 
		"LEQ", "LETTER", "LS", "MUL", "NOT", "OPENPAREN", "READ", "RS", "SEMICOLON", 
		"SKIP", "STRING", "SUB", "THEN", "TRUE", "WHILE", "WRITE", "WRITELN", 
		"WS"
	};
	public static final int EOF=-1;
	public static final int ADD=4;
	public static final int AND=5;
	public static final int ASSIGN=6;
	public static final int CLOSEPAREN=7;
	public static final int COMMENT=8;
	public static final int DEF=9;
	public static final int DIGIT=10;
	public static final int DO=11;
	public static final int ELSE=12;
	public static final int EQ=13;
	public static final int FALSE=14;
	public static final int ID=15;
	public static final int IF=16;
	public static final int INTNUM=17;
	public static final int LEQ=18;
	public static final int LETTER=19;
	public static final int LS=20;
	public static final int MUL=21;
	public static final int NOT=22;
	public static final int OPENPAREN=23;
	public static final int READ=24;
	public static final int RS=25;
	public static final int SEMICOLON=26;
	public static final int SKIP=27;
	public static final int STRING=28;
	public static final int SUB=29;
	public static final int THEN=30;
	public static final int TRUE=31;
	public static final int WHILE=32;
	public static final int WRITE=33;
	public static final int WRITELN=34;
	public static final int WS=35;

	// delegates
	public Parser[] getDelegates() {
		return new Parser[] {};
	}

	// delegators


	public Syn(TokenStream input) {
		this(input, new RecognizerSharedState());
	}
	public Syn(TokenStream input, RecognizerSharedState state) {
		super(input, state);
		this.state.ruleMemo = new HashMap[15+1];


	}

	protected TreeAdaptor adaptor = new CommonTreeAdaptor();

	public void setTreeAdaptor(TreeAdaptor adaptor) {
		this.adaptor = adaptor;
	}
	public TreeAdaptor getTreeAdaptor() {
		return adaptor;
	}
	@Override public String[] getTokenNames() { return Syn.tokenNames; }
	@Override public String getGrammarFileName() { return "Syn.g"; }


	    boolean errorFound = false;
	    Stack paraphrases = new Stack();
	    private Set<String> symbolTable = new HashSet<String>();

		private String cleanString(String s){
			String tmp;
			tmp = s.replaceAll("^'", "");
			s = tmp.replaceAll("'$", "");
			tmp = s.replaceAll("''", "'");
			return tmp;
		}
	    
	    public String getErrorMessage(RecognitionException e, String[] tokenNames){
	        String msg = super.getErrorMessage(e, tokenNames);
	        if(paraphrases.size()>0) {
	            String paraphrase = (String)paraphrases.peek();
	            msg = msg+" "+paraphrase;
	        }
	        if(msg.contains("EOF")&&!msg.contains("<EOF>"))
	            return "missing \";\" between statements";
	        return msg;
	    }

	    public boolean getErrorFound(){
	        return errorFound;
	    }

	//    protected void mismatch(IntStream input, int ttype, BitSet follow)
	//        throws RecognitionException
	//    {
	//        throw new MismatchedTokenException(ttype, input);
	//    }
	//    public Object recoverFromMismatchedSet(IntStream input, RecognitionException e, BitSet follow)
	//        throws RecognitionException
	//    {
	//        throw e;
	//    }



	public static class program_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "program"
	// Syn.g:66:1: program : statements ;
	public final Syn.program_return program() throws RecognitionException {
		Syn.program_return retval = new Syn.program_return();
		retval.start = input.LT(1);
		int program_StartIndex = input.index();

		Object root_0 = null;

		ParserRuleReturnScope statements1 =null;


		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 1) ) { return retval; }

			// Syn.g:66:9: ( statements )
			// Syn.g:67:5: statements
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_statements_in_program68);
			statements1=statements();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, statements1.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 1, program_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "program"


	public static class statements_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statements"
	// Syn.g:70:1: statements : statement ( SEMICOLON ^ statement )* EOF ;
	public final Syn.statements_return statements() throws RecognitionException {
		Syn.statements_return retval = new Syn.statements_return();
		retval.start = input.LT(1);
		int statements_StartIndex = input.index();

		Object root_0 = null;

		Token SEMICOLON3=null;
		Token EOF5=null;
		ParserRuleReturnScope statement2 =null;
		ParserRuleReturnScope statement4 =null;

		Object SEMICOLON3_tree=null;
		Object EOF5_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 2) ) { return retval; }

			// Syn.g:70:12: ( statement ( SEMICOLON ^ statement )* EOF )
			// Syn.g:71:5: statement ( SEMICOLON ^ statement )* EOF
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_statement_in_statements83);
			statement2=statement();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, statement2.getTree());

			// Syn.g:71:15: ( SEMICOLON ^ statement )*
			loop1:
			while (true) {
				int alt1=2;
				int LA1_0 = input.LA(1);
				if ( (LA1_0==SEMICOLON) ) {
					alt1=1;
				}

				switch (alt1) {
				case 1 :
					// Syn.g:71:17: SEMICOLON ^ statement
					{
					SEMICOLON3=(Token)match(input,SEMICOLON,FOLLOW_SEMICOLON_in_statements87); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					SEMICOLON3_tree = (Object)adaptor.create(SEMICOLON3);
					root_0 = (Object)adaptor.becomeRoot(SEMICOLON3_tree, root_0);
					}

					pushFollow(FOLLOW_statement_in_statements90);
					statement4=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, statement4.getTree());

					}
					break;

				default :
					break loop1;
				}
			}

			EOF5=(Token)match(input,EOF,FOLLOW_EOF_in_statements95); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			EOF5_tree = (Object)adaptor.create(EOF5);
			adaptor.addChild(root_0, EOF5_tree);
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 2, statements_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "statements"


	public static class statement_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "statement"
	// Syn.g:74:1: statement : ( ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)=> ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !) | WRITE ^ OPENPAREN ! ( string | boolexp ) CLOSEPAREN !| WRITELN | ( ID ASSIGN ^ exp )=> (var= ID ASSIGN ^ exp ) | DEF ^ ID LS ! INTNUM RS !| array ASSIGN ^ exp | READ ^ OPENPAREN ! ID CLOSEPAREN !| SKIP | IF ^ boolexp THEN ! statement ELSE ! statement | WHILE ^ boolexp DO ! statement | OPENPAREN ! statements CLOSEPAREN !);
	public final Syn.statement_return statement() throws RecognitionException {
		Syn.statement_return retval = new Syn.statement_return();
		retval.start = input.LT(1);
		int statement_StartIndex = input.index();

		Object root_0 = null;

		Token var=null;
		Token WRITE6=null;
		Token OPENPAREN7=null;
		Token CLOSEPAREN9=null;
		Token WRITE10=null;
		Token OPENPAREN11=null;
		Token CLOSEPAREN14=null;
		Token WRITELN15=null;
		Token ASSIGN16=null;
		Token DEF18=null;
		Token ID19=null;
		Token LS20=null;
		Token INTNUM21=null;
		Token RS22=null;
		Token ASSIGN24=null;
		Token READ26=null;
		Token OPENPAREN27=null;
		Token ID28=null;
		Token CLOSEPAREN29=null;
		Token SKIP30=null;
		Token IF31=null;
		Token THEN33=null;
		Token ELSE35=null;
		Token WHILE37=null;
		Token DO39=null;
		Token OPENPAREN41=null;
		Token CLOSEPAREN43=null;
		ParserRuleReturnScope exp8 =null;
		ParserRuleReturnScope string12 =null;
		ParserRuleReturnScope boolexp13 =null;
		ParserRuleReturnScope exp17 =null;
		ParserRuleReturnScope array23 =null;
		ParserRuleReturnScope exp25 =null;
		ParserRuleReturnScope boolexp32 =null;
		ParserRuleReturnScope statement34 =null;
		ParserRuleReturnScope statement36 =null;
		ParserRuleReturnScope boolexp38 =null;
		ParserRuleReturnScope statement40 =null;
		ParserRuleReturnScope statements42 =null;

		Object var_tree=null;
		Object WRITE6_tree=null;
		Object OPENPAREN7_tree=null;
		Object CLOSEPAREN9_tree=null;
		Object WRITE10_tree=null;
		Object OPENPAREN11_tree=null;
		Object CLOSEPAREN14_tree=null;
		Object WRITELN15_tree=null;
		Object ASSIGN16_tree=null;
		Object DEF18_tree=null;
		Object ID19_tree=null;
		Object LS20_tree=null;
		Object INTNUM21_tree=null;
		Object RS22_tree=null;
		Object ASSIGN24_tree=null;
		Object READ26_tree=null;
		Object OPENPAREN27_tree=null;
		Object ID28_tree=null;
		Object CLOSEPAREN29_tree=null;
		Object SKIP30_tree=null;
		Object IF31_tree=null;
		Object THEN33_tree=null;
		Object ELSE35_tree=null;
		Object WHILE37_tree=null;
		Object DO39_tree=null;
		Object OPENPAREN41_tree=null;
		Object CLOSEPAREN43_tree=null;

		 paraphrases.push("in statement"); 
		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 3) ) { return retval; }

			// Syn.g:77:3: ( ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)=> ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !) | WRITE ^ OPENPAREN ! ( string | boolexp ) CLOSEPAREN !| WRITELN | ( ID ASSIGN ^ exp )=> (var= ID ASSIGN ^ exp ) | DEF ^ ID LS ! INTNUM RS !| array ASSIGN ^ exp | READ ^ OPENPAREN ! ID CLOSEPAREN !| SKIP | IF ^ boolexp THEN ! statement ELSE ! statement | WHILE ^ boolexp DO ! statement | OPENPAREN ! statements CLOSEPAREN !)
			int alt3=11;
			switch ( input.LA(1) ) {
			case WRITE:
				{
				int LA3_1 = input.LA(2);
				if ( (synpred1_Syn()) ) {
					alt3=1;
				}
				else if ( (true) ) {
					alt3=2;
				}

				}
				break;
			case WRITELN:
				{
				alt3=3;
				}
				break;
			case ID:
				{
				int LA3_3 = input.LA(2);
				if ( (synpred2_Syn()) ) {
					alt3=4;
				}
				else if ( (true) ) {
					alt3=6;
				}

				}
				break;
			case DEF:
				{
				alt3=5;
				}
				break;
			case READ:
				{
				alt3=7;
				}
				break;
			case SKIP:
				{
				alt3=8;
				}
				break;
			case IF:
				{
				alt3=9;
				}
				break;
			case WHILE:
				{
				alt3=10;
				}
				break;
			case OPENPAREN:
				{
				alt3=11;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 3, 0, input);
				throw nvae;
			}
			switch (alt3) {
				case 1 :
					// Syn.g:77:6: ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)=> ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)
					{
					root_0 = (Object)adaptor.nil();


					// Syn.g:77:45: ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)
					// Syn.g:77:46: WRITE ^ OPENPAREN ! exp CLOSEPAREN !
					{
					WRITE6=(Token)match(input,WRITE,FOLLOW_WRITE_in_statement136); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					WRITE6_tree = (Object)adaptor.create(WRITE6);
					root_0 = (Object)adaptor.becomeRoot(WRITE6_tree, root_0);
					}

					OPENPAREN7=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_statement139); if (state.failed) return retval;
					pushFollow(FOLLOW_exp_in_statement142);
					exp8=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp8.getTree());

					CLOSEPAREN9=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_statement144); if (state.failed) return retval;
					}

					}
					break;
				case 2 :
					// Syn.g:78:5: WRITE ^ OPENPAREN ! ( string | boolexp ) CLOSEPAREN !
					{
					root_0 = (Object)adaptor.nil();


					WRITE10=(Token)match(input,WRITE,FOLLOW_WRITE_in_statement152); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					WRITE10_tree = (Object)adaptor.create(WRITE10);
					root_0 = (Object)adaptor.becomeRoot(WRITE10_tree, root_0);
					}

					OPENPAREN11=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_statement155); if (state.failed) return retval;
					// Syn.g:78:23: ( string | boolexp )
					int alt2=2;
					int LA2_0 = input.LA(1);
					if ( (LA2_0==STRING) ) {
						alt2=1;
					}
					else if ( ((LA2_0 >= FALSE && LA2_0 <= ID)||LA2_0==INTNUM||(LA2_0 >= NOT && LA2_0 <= OPENPAREN)||LA2_0==TRUE) ) {
						alt2=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae =
							new NoViableAltException("", 2, 0, input);
						throw nvae;
					}

					switch (alt2) {
						case 1 :
							// Syn.g:78:25: string
							{
							pushFollow(FOLLOW_string_in_statement160);
							string12=string();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, string12.getTree());

							}
							break;
						case 2 :
							// Syn.g:78:34: boolexp
							{
							pushFollow(FOLLOW_boolexp_in_statement164);
							boolexp13=boolexp();
							state._fsp--;
							if (state.failed) return retval;
							if ( state.backtracking==0 ) adaptor.addChild(root_0, boolexp13.getTree());

							}
							break;

					}

					CLOSEPAREN14=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_statement168); if (state.failed) return retval;
					}
					break;
				case 3 :
					// Syn.g:79:5: WRITELN
					{
					root_0 = (Object)adaptor.nil();


					WRITELN15=(Token)match(input,WRITELN,FOLLOW_WRITELN_in_statement175); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					WRITELN15_tree = (Object)adaptor.create(WRITELN15);
					adaptor.addChild(root_0, WRITELN15_tree);
					}

					}
					break;
				case 4 :
					// Syn.g:80:5: ( ID ASSIGN ^ exp )=> (var= ID ASSIGN ^ exp )
					{
					root_0 = (Object)adaptor.nil();


					// Syn.g:80:25: (var= ID ASSIGN ^ exp )
					// Syn.g:80:26: var= ID ASSIGN ^ exp
					{
					var=(Token)match(input,ID,FOLLOW_ID_in_statement195); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					var_tree = (Object)adaptor.create(var);
					adaptor.addChild(root_0, var_tree);
					}

					ASSIGN16=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_statement197); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ASSIGN16_tree = (Object)adaptor.create(ASSIGN16);
					root_0 = (Object)adaptor.becomeRoot(ASSIGN16_tree, root_0);
					}

					pushFollow(FOLLOW_exp_in_statement200);
					exp17=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp17.getTree());

					}

					if ( state.backtracking==0 ) {symbolTable.add(var.getText());}
					}
					break;
				case 5 :
					// Syn.g:81:5: DEF ^ ID LS ! INTNUM RS !
					{
					root_0 = (Object)adaptor.nil();


					DEF18=(Token)match(input,DEF,FOLLOW_DEF_in_statement209); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					DEF18_tree = (Object)adaptor.create(DEF18);
					root_0 = (Object)adaptor.becomeRoot(DEF18_tree, root_0);
					}

					ID19=(Token)match(input,ID,FOLLOW_ID_in_statement212); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ID19_tree = (Object)adaptor.create(ID19);
					adaptor.addChild(root_0, ID19_tree);
					}

					LS20=(Token)match(input,LS,FOLLOW_LS_in_statement214); if (state.failed) return retval;
					INTNUM21=(Token)match(input,INTNUM,FOLLOW_INTNUM_in_statement217); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTNUM21_tree = (Object)adaptor.create(INTNUM21);
					adaptor.addChild(root_0, INTNUM21_tree);
					}

					RS22=(Token)match(input,RS,FOLLOW_RS_in_statement219); if (state.failed) return retval;
					}
					break;
				case 6 :
					// Syn.g:82:5: array ASSIGN ^ exp
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_array_in_statement226);
					array23=array();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, array23.getTree());

					ASSIGN24=(Token)match(input,ASSIGN,FOLLOW_ASSIGN_in_statement228); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ASSIGN24_tree = (Object)adaptor.create(ASSIGN24);
					root_0 = (Object)adaptor.becomeRoot(ASSIGN24_tree, root_0);
					}

					pushFollow(FOLLOW_exp_in_statement231);
					exp25=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp25.getTree());

					}
					break;
				case 7 :
					// Syn.g:83:5: READ ^ OPENPAREN ! ID CLOSEPAREN !
					{
					root_0 = (Object)adaptor.nil();


					READ26=(Token)match(input,READ,FOLLOW_READ_in_statement237); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					READ26_tree = (Object)adaptor.create(READ26);
					root_0 = (Object)adaptor.becomeRoot(READ26_tree, root_0);
					}

					OPENPAREN27=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_statement240); if (state.failed) return retval;
					ID28=(Token)match(input,ID,FOLLOW_ID_in_statement243); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					ID28_tree = (Object)adaptor.create(ID28);
					adaptor.addChild(root_0, ID28_tree);
					}

					CLOSEPAREN29=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_statement245); if (state.failed) return retval;
					}
					break;
				case 8 :
					// Syn.g:84:5: SKIP
					{
					root_0 = (Object)adaptor.nil();


					SKIP30=(Token)match(input,SKIP,FOLLOW_SKIP_in_statement252); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					SKIP30_tree = (Object)adaptor.create(SKIP30);
					adaptor.addChild(root_0, SKIP30_tree);
					}

					}
					break;
				case 9 :
					// Syn.g:85:5: IF ^ boolexp THEN ! statement ELSE ! statement
					{
					root_0 = (Object)adaptor.nil();


					IF31=(Token)match(input,IF,FOLLOW_IF_in_statement258); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					IF31_tree = (Object)adaptor.create(IF31);
					root_0 = (Object)adaptor.becomeRoot(IF31_tree, root_0);
					}

					pushFollow(FOLLOW_boolexp_in_statement261);
					boolexp32=boolexp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, boolexp32.getTree());

					THEN33=(Token)match(input,THEN,FOLLOW_THEN_in_statement263); if (state.failed) return retval;
					pushFollow(FOLLOW_statement_in_statement266);
					statement34=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, statement34.getTree());

					ELSE35=(Token)match(input,ELSE,FOLLOW_ELSE_in_statement268); if (state.failed) return retval;
					pushFollow(FOLLOW_statement_in_statement271);
					statement36=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, statement36.getTree());

					}
					break;
				case 10 :
					// Syn.g:86:5: WHILE ^ boolexp DO ! statement
					{
					root_0 = (Object)adaptor.nil();


					WHILE37=(Token)match(input,WHILE,FOLLOW_WHILE_in_statement277); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					WHILE37_tree = (Object)adaptor.create(WHILE37);
					root_0 = (Object)adaptor.becomeRoot(WHILE37_tree, root_0);
					}

					pushFollow(FOLLOW_boolexp_in_statement280);
					boolexp38=boolexp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, boolexp38.getTree());

					DO39=(Token)match(input,DO,FOLLOW_DO_in_statement282); if (state.failed) return retval;
					pushFollow(FOLLOW_statement_in_statement285);
					statement40=statement();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, statement40.getTree());

					}
					break;
				case 11 :
					// Syn.g:87:5: OPENPAREN ! statements CLOSEPAREN !
					{
					root_0 = (Object)adaptor.nil();


					OPENPAREN41=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_statement291); if (state.failed) return retval;
					pushFollow(FOLLOW_statements_in_statement294);
					statements42=statements();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, statements42.getTree());

					CLOSEPAREN43=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_statement296); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) { paraphrases.pop(); }
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 3, statement_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "statement"


	public static class array_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "array"
	// Syn.g:90:10: fragment array : ( ID ^ LS ! exp RS !) ;
	public final Syn.array_return array() throws RecognitionException {
		Syn.array_return retval = new Syn.array_return();
		retval.start = input.LT(1);
		int array_StartIndex = input.index();

		Object root_0 = null;

		Token ID44=null;
		Token LS45=null;
		Token RS47=null;
		ParserRuleReturnScope exp46 =null;

		Object ID44_tree=null;
		Object LS45_tree=null;
		Object RS47_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 4) ) { return retval; }

			// Syn.g:90:16: ( ( ID ^ LS ! exp RS !) )
			// Syn.g:91:5: ( ID ^ LS ! exp RS !)
			{
			root_0 = (Object)adaptor.nil();


			// Syn.g:91:5: ( ID ^ LS ! exp RS !)
			// Syn.g:91:6: ID ^ LS ! exp RS !
			{
			ID44=(Token)match(input,ID,FOLLOW_ID_in_array315); if (state.failed) return retval;
			if ( state.backtracking==0 ) {
			ID44_tree = (Object)adaptor.create(ID44);
			root_0 = (Object)adaptor.becomeRoot(ID44_tree, root_0);
			}

			LS45=(Token)match(input,LS,FOLLOW_LS_in_array318); if (state.failed) return retval;
			pushFollow(FOLLOW_exp_in_array321);
			exp46=exp();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, exp46.getTree());

			RS47=(Token)match(input,RS,FOLLOW_RS_in_array323); if (state.failed) return retval;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 4, array_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "array"


	public static class boolexp_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "boolexp"
	// Syn.g:94:1: boolexp : boolterm ( AND ^ boolterm )* ;
	public final Syn.boolexp_return boolexp() throws RecognitionException {
		Syn.boolexp_return retval = new Syn.boolexp_return();
		retval.start = input.LT(1);
		int boolexp_StartIndex = input.index();

		Object root_0 = null;

		Token AND49=null;
		ParserRuleReturnScope boolterm48 =null;
		ParserRuleReturnScope boolterm50 =null;

		Object AND49_tree=null;

		 paraphrases.push("in boolean expression"); 
		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 5) ) { return retval; }

			// Syn.g:97:3: ( boolterm ( AND ^ boolterm )* )
			// Syn.g:97:6: boolterm ( AND ^ boolterm )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_boolterm_in_boolexp350);
			boolterm48=boolterm();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, boolterm48.getTree());

			// Syn.g:97:15: ( AND ^ boolterm )*
			loop4:
			while (true) {
				int alt4=2;
				int LA4_0 = input.LA(1);
				if ( (LA4_0==AND) ) {
					alt4=1;
				}

				switch (alt4) {
				case 1 :
					// Syn.g:97:16: AND ^ boolterm
					{
					AND49=(Token)match(input,AND,FOLLOW_AND_in_boolexp353); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					AND49_tree = (Object)adaptor.create(AND49);
					root_0 = (Object)adaptor.becomeRoot(AND49_tree, root_0);
					}

					pushFollow(FOLLOW_boolterm_in_boolexp356);
					boolterm50=boolterm();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, boolterm50.getTree());

					}
					break;

				default :
					break loop4;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) { paraphrases.pop(); }
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 5, boolexp_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "boolexp"


	public static class boolterm_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "boolterm"
	// Syn.g:100:1: boolterm : ( NOT ^)? bool ;
	public final Syn.boolterm_return boolterm() throws RecognitionException {
		Syn.boolterm_return retval = new Syn.boolterm_return();
		retval.start = input.LT(1);
		int boolterm_StartIndex = input.index();

		Object root_0 = null;

		Token NOT51=null;
		ParserRuleReturnScope bool52 =null;

		Object NOT51_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 6) ) { return retval; }

			// Syn.g:100:10: ( ( NOT ^)? bool )
			// Syn.g:101:5: ( NOT ^)? bool
			{
			root_0 = (Object)adaptor.nil();


			// Syn.g:101:5: ( NOT ^)?
			int alt5=2;
			int LA5_0 = input.LA(1);
			if ( (LA5_0==NOT) ) {
				alt5=1;
			}
			switch (alt5) {
				case 1 :
					// Syn.g:101:6: NOT ^
					{
					NOT51=(Token)match(input,NOT,FOLLOW_NOT_in_boolterm374); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					NOT51_tree = (Object)adaptor.create(NOT51);
					root_0 = (Object)adaptor.becomeRoot(NOT51_tree, root_0);
					}

					}
					break;

			}

			pushFollow(FOLLOW_bool_in_boolterm379);
			bool52=bool();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, bool52.getTree());

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 6, boolterm_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "boolterm"


	public static class bool_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bool"
	// Syn.g:104:1: bool : ( TRUE | FALSE | ( exp bop ^ exp )=> ( exp bop ^ exp ) | OPENPAREN ! boolexp CLOSEPAREN !);
	public final Syn.bool_return bool() throws RecognitionException {
		Syn.bool_return retval = new Syn.bool_return();
		retval.start = input.LT(1);
		int bool_StartIndex = input.index();

		Object root_0 = null;

		Token TRUE53=null;
		Token FALSE54=null;
		Token OPENPAREN58=null;
		Token CLOSEPAREN60=null;
		ParserRuleReturnScope exp55 =null;
		ParserRuleReturnScope bop56 =null;
		ParserRuleReturnScope exp57 =null;
		ParserRuleReturnScope boolexp59 =null;

		Object TRUE53_tree=null;
		Object FALSE54_tree=null;
		Object OPENPAREN58_tree=null;
		Object CLOSEPAREN60_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 7) ) { return retval; }

			// Syn.g:104:6: ( TRUE | FALSE | ( exp bop ^ exp )=> ( exp bop ^ exp ) | OPENPAREN ! boolexp CLOSEPAREN !)
			int alt6=4;
			int LA6_0 = input.LA(1);
			if ( (LA6_0==TRUE) ) {
				alt6=1;
			}
			else if ( (LA6_0==FALSE) ) {
				alt6=2;
			}
			else if ( (LA6_0==ID) && (synpred3_Syn())) {
				alt6=3;
			}
			else if ( (LA6_0==INTNUM) && (synpred3_Syn())) {
				alt6=3;
			}
			else if ( (LA6_0==OPENPAREN) ) {
				int LA6_5 = input.LA(2);
				if ( (synpred3_Syn()) ) {
					alt6=3;
				}
				else if ( (true) ) {
					alt6=4;
				}

			}

			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 6, 0, input);
				throw nvae;
			}

			switch (alt6) {
				case 1 :
					// Syn.g:105:5: TRUE
					{
					root_0 = (Object)adaptor.nil();


					TRUE53=(Token)match(input,TRUE,FOLLOW_TRUE_in_bool394); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					TRUE53_tree = (Object)adaptor.create(TRUE53);
					adaptor.addChild(root_0, TRUE53_tree);
					}

					}
					break;
				case 2 :
					// Syn.g:105:12: FALSE
					{
					root_0 = (Object)adaptor.nil();


					FALSE54=(Token)match(input,FALSE,FOLLOW_FALSE_in_bool398); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					FALSE54_tree = (Object)adaptor.create(FALSE54);
					adaptor.addChild(root_0, FALSE54_tree);
					}

					}
					break;
				case 3 :
					// Syn.g:106:5: ( exp bop ^ exp )=> ( exp bop ^ exp )
					{
					root_0 = (Object)adaptor.nil();


					// Syn.g:106:21: ( exp bop ^ exp )
					// Syn.g:106:22: exp bop ^ exp
					{
					pushFollow(FOLLOW_exp_in_bool414);
					exp55=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp55.getTree());

					pushFollow(FOLLOW_bop_in_bool416);
					bop56=bop();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot(bop56.getTree(), root_0);
					pushFollow(FOLLOW_exp_in_bool419);
					exp57=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp57.getTree());

					}

					}
					break;
				case 4 :
					// Syn.g:107:5: OPENPAREN ! boolexp CLOSEPAREN !
					{
					root_0 = (Object)adaptor.nil();


					OPENPAREN58=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_bool426); if (state.failed) return retval;
					pushFollow(FOLLOW_boolexp_in_bool429);
					boolexp59=boolexp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, boolexp59.getTree());

					CLOSEPAREN60=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_bool431); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 7, bool_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "bool"


	public static class bop_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "bop"
	// Syn.g:110:10: fragment bop : ( EQ | LEQ );
	public final Syn.bop_return bop() throws RecognitionException {
		Syn.bop_return retval = new Syn.bop_return();
		retval.start = input.LT(1);
		int bop_StartIndex = input.index();

		Object root_0 = null;

		Token set61=null;

		Object set61_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 8) ) { return retval; }

			// Syn.g:110:14: ( EQ | LEQ )
			// Syn.g:
			{
			root_0 = (Object)adaptor.nil();


			set61=input.LT(1);
			if ( input.LA(1)==EQ||input.LA(1)==LEQ ) {
				input.consume();
				if ( state.backtracking==0 ) adaptor.addChild(root_0, (Object)adaptor.create(set61));
				state.errorRecovery=false;
				state.failed=false;
			}
			else {
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				throw mse;
			}
			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 8, bop_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "bop"


	public static class exp_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "exp"
	// Syn.g:114:1: exp : term ( ( ADD | SUB ) ^ term )* ;
	public final Syn.exp_return exp() throws RecognitionException {
		Syn.exp_return retval = new Syn.exp_return();
		retval.start = input.LT(1);
		int exp_StartIndex = input.index();

		Object root_0 = null;

		Token set63=null;
		ParserRuleReturnScope term62 =null;
		ParserRuleReturnScope term64 =null;

		Object set63_tree=null;

		 paraphrases.push("in expression"); 
		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 9) ) { return retval; }

			// Syn.g:117:3: ( term ( ( ADD | SUB ) ^ term )* )
			// Syn.g:117:6: term ( ( ADD | SUB ) ^ term )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_term_in_exp478);
			term62=term();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, term62.getTree());

			// Syn.g:117:11: ( ( ADD | SUB ) ^ term )*
			loop7:
			while (true) {
				int alt7=2;
				int LA7_0 = input.LA(1);
				if ( (LA7_0==ADD||LA7_0==SUB) ) {
					alt7=1;
				}

				switch (alt7) {
				case 1 :
					// Syn.g:117:13: ( ADD | SUB ) ^ term
					{
					set63=input.LT(1);
					set63=input.LT(1);
					if ( input.LA(1)==ADD||input.LA(1)==SUB ) {
						input.consume();
						if ( state.backtracking==0 ) root_0 = (Object)adaptor.becomeRoot((Object)adaptor.create(set63), root_0);
						state.errorRecovery=false;
						state.failed=false;
					}
					else {
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						throw mse;
					}
					pushFollow(FOLLOW_term_in_exp493);
					term64=term();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, term64.getTree());

					}
					break;

				default :
					break loop7;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
			if ( state.backtracking==0 ) { paraphrases.pop(); }
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 9, exp_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "exp"


	public static class term_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "term"
	// Syn.g:120:1: term : factor ( MUL ^ factor )* ;
	public final Syn.term_return term() throws RecognitionException {
		Syn.term_return retval = new Syn.term_return();
		retval.start = input.LT(1);
		int term_StartIndex = input.index();

		Object root_0 = null;

		Token MUL66=null;
		ParserRuleReturnScope factor65 =null;
		ParserRuleReturnScope factor67 =null;

		Object MUL66_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 10) ) { return retval; }

			// Syn.g:120:6: ( factor ( MUL ^ factor )* )
			// Syn.g:121:5: factor ( MUL ^ factor )*
			{
			root_0 = (Object)adaptor.nil();


			pushFollow(FOLLOW_factor_in_term511);
			factor65=factor();
			state._fsp--;
			if (state.failed) return retval;
			if ( state.backtracking==0 ) adaptor.addChild(root_0, factor65.getTree());

			// Syn.g:121:12: ( MUL ^ factor )*
			loop8:
			while (true) {
				int alt8=2;
				int LA8_0 = input.LA(1);
				if ( (LA8_0==MUL) ) {
					alt8=1;
				}

				switch (alt8) {
				case 1 :
					// Syn.g:121:14: MUL ^ factor
					{
					MUL66=(Token)match(input,MUL,FOLLOW_MUL_in_term515); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					MUL66_tree = (Object)adaptor.create(MUL66);
					root_0 = (Object)adaptor.becomeRoot(MUL66_tree, root_0);
					}

					pushFollow(FOLLOW_factor_in_term518);
					factor67=factor();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, factor67.getTree());

					}
					break;

				default :
					break loop8;
				}
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 10, term_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "term"


	public static class factor_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "factor"
	// Syn.g:124:1: factor : (var= ID | INTNUM | array | OPENPAREN ! exp CLOSEPAREN !);
	public final Syn.factor_return factor() throws RecognitionException {
		Syn.factor_return retval = new Syn.factor_return();
		retval.start = input.LT(1);
		int factor_StartIndex = input.index();

		Object root_0 = null;

		Token var=null;
		Token INTNUM68=null;
		Token OPENPAREN70=null;
		Token CLOSEPAREN72=null;
		ParserRuleReturnScope array69 =null;
		ParserRuleReturnScope exp71 =null;

		Object var_tree=null;
		Object INTNUM68_tree=null;
		Object OPENPAREN70_tree=null;
		Object CLOSEPAREN72_tree=null;

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 11) ) { return retval; }

			// Syn.g:124:8: (var= ID | INTNUM | array | OPENPAREN ! exp CLOSEPAREN !)
			int alt9=4;
			switch ( input.LA(1) ) {
			case ID:
				{
				int LA9_1 = input.LA(2);
				if ( (LA9_1==LS) ) {
					alt9=3;
				}
				else if ( (LA9_1==EOF||(LA9_1 >= ADD && LA9_1 <= AND)||LA9_1==CLOSEPAREN||(LA9_1 >= DO && LA9_1 <= EQ)||LA9_1==LEQ||LA9_1==MUL||(LA9_1 >= RS && LA9_1 <= SEMICOLON)||(LA9_1 >= SUB && LA9_1 <= THEN)) ) {
					alt9=1;
				}

				else {
					if (state.backtracking>0) {state.failed=true; return retval;}
					int nvaeMark = input.mark();
					try {
						input.consume();
						NoViableAltException nvae =
							new NoViableAltException("", 9, 1, input);
						throw nvae;
					} finally {
						input.rewind(nvaeMark);
					}
				}

				}
				break;
			case INTNUM:
				{
				alt9=2;
				}
				break;
			case OPENPAREN:
				{
				alt9=4;
				}
				break;
			default:
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae =
					new NoViableAltException("", 9, 0, input);
				throw nvae;
			}
			switch (alt9) {
				case 1 :
					// Syn.g:125:5: var= ID
					{
					root_0 = (Object)adaptor.nil();


					var=(Token)match(input,ID,FOLLOW_ID_in_factor538); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					var_tree = (Object)adaptor.create(var);
					adaptor.addChild(root_0, var_tree);
					}

					if ( state.backtracking==0 ) {!symbolTable.contains(var.getText())?throw new RecognitionException("Undeclared "+var.getText());}
					}
					break;
				case 2 :
					// Syn.g:126:5: INTNUM
					{
					root_0 = (Object)adaptor.nil();


					INTNUM68=(Token)match(input,INTNUM,FOLLOW_INTNUM_in_factor546); if (state.failed) return retval;
					if ( state.backtracking==0 ) {
					INTNUM68_tree = (Object)adaptor.create(INTNUM68);
					adaptor.addChild(root_0, INTNUM68_tree);
					}

					}
					break;
				case 3 :
					// Syn.g:127:5: array
					{
					root_0 = (Object)adaptor.nil();


					pushFollow(FOLLOW_array_in_factor552);
					array69=array();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, array69.getTree());

					}
					break;
				case 4 :
					// Syn.g:128:5: OPENPAREN ! exp CLOSEPAREN !
					{
					root_0 = (Object)adaptor.nil();


					OPENPAREN70=(Token)match(input,OPENPAREN,FOLLOW_OPENPAREN_in_factor558); if (state.failed) return retval;
					pushFollow(FOLLOW_exp_in_factor561);
					exp71=exp();
					state._fsp--;
					if (state.failed) return retval;
					if ( state.backtracking==0 ) adaptor.addChild(root_0, exp71.getTree());

					CLOSEPAREN72=(Token)match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_factor563); if (state.failed) return retval;
					}
					break;

			}
			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 11, factor_StartIndex); }

		}
		return retval;
	}
	// $ANTLR end "factor"


	protected static class string_scope {
		String tmp;
	}
	protected Stack<string_scope> string_stack = new Stack<string_scope>();

	public static class string_return extends ParserRuleReturnScope {
		Object tree;
		@Override
		public Object getTree() { return tree; }
	};


	// $ANTLR start "string"
	// Syn.g:131:1: string : s= STRING -> STRING[$string::tmp] ;
	public final Syn.string_return string() throws RecognitionException {
		string_stack.push(new string_scope());
		Syn.string_return retval = new Syn.string_return();
		retval.start = input.LT(1);
		int string_StartIndex = input.index();

		Object root_0 = null;

		Token s=null;

		Object s_tree=null;
		RewriteRuleTokenStream stream_STRING=new RewriteRuleTokenStream(adaptor,"token STRING");

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 12) ) { return retval; }

			// Syn.g:133:3: (s= STRING -> STRING[$string::tmp] )
			// Syn.g:133:5: s= STRING
			{
			s=(Token)match(input,STRING,FOLLOW_STRING_in_string583); if (state.failed) return retval; 
			if ( state.backtracking==0 ) stream_STRING.add(s);

			if ( state.backtracking==0 ) { string_stack.peek().tmp = cleanString((s!=null?s.getText():null)); }
			// AST REWRITE
			// elements: STRING
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if ( state.backtracking==0 ) {
			retval.tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.getTree():null);

			root_0 = (Object)adaptor.nil();
			// 133:54: -> STRING[$string::tmp]
			{
				adaptor.addChild(root_0, (Object)adaptor.create(STRING, string_stack.peek().tmp));
			}


			retval.tree = root_0;
			}

			}

			retval.stop = input.LT(-1);

			if ( state.backtracking==0 ) {
			retval.tree = (Object)adaptor.rulePostProcessing(root_0);
			adaptor.setTokenBoundaries(retval.tree, retval.start, retval.stop);
			}
		}

		    catch (RecognitionException e){
		        errorFound = true;
		        reportError(e);
		        recover(input,e);
		    }

		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 12, string_StartIndex); }

			string_stack.pop();
		}
		return retval;
	}
	// $ANTLR end "string"

	// $ANTLR start synpred1_Syn
	public final void synpred1_Syn_fragment() throws RecognitionException {
		// Syn.g:77:6: ( WRITE ^ OPENPAREN ! exp CLOSEPAREN !)
		// Syn.g:77:7: WRITE ^ OPENPAREN ! exp CLOSEPAREN !
		{
		match(input,WRITE,FOLLOW_WRITE_in_synpred1_Syn121); if (state.failed) return;

		match(input,OPENPAREN,FOLLOW_OPENPAREN_in_synpred1_Syn124); if (state.failed) return;

		pushFollow(FOLLOW_exp_in_synpred1_Syn127);
		exp();
		state._fsp--;
		if (state.failed) return;

		match(input,CLOSEPAREN,FOLLOW_CLOSEPAREN_in_synpred1_Syn129); if (state.failed) return;

		}

	}
	// $ANTLR end synpred1_Syn

	// $ANTLR start synpred2_Syn
	public final void synpred2_Syn_fragment() throws RecognitionException {
		// Syn.g:80:5: ( ID ASSIGN ^ exp )
		// Syn.g:80:6: ID ASSIGN ^ exp
		{
		match(input,ID,FOLLOW_ID_in_synpred2_Syn182); if (state.failed) return;

		match(input,ASSIGN,FOLLOW_ASSIGN_in_synpred2_Syn184); if (state.failed) return;

		pushFollow(FOLLOW_exp_in_synpred2_Syn187);
		exp();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred2_Syn

	// $ANTLR start synpred3_Syn
	public final void synpred3_Syn_fragment() throws RecognitionException {
		// Syn.g:106:5: ( exp bop ^ exp )
		// Syn.g:106:6: exp bop ^ exp
		{
		pushFollow(FOLLOW_exp_in_synpred3_Syn405);
		exp();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_bop_in_synpred3_Syn407);
		bop();
		state._fsp--;
		if (state.failed) return;

		pushFollow(FOLLOW_exp_in_synpred3_Syn410);
		exp();
		state._fsp--;
		if (state.failed) return;

		}

	}
	// $ANTLR end synpred3_Syn

	// Delegated rules

	public final boolean synpred1_Syn() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred1_Syn_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred2_Syn() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred2_Syn_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}
	public final boolean synpred3_Syn() {
		state.backtracking++;
		int start = input.mark();
		try {
			synpred3_Syn_fragment(); // can never throw exception
		} catch (RecognitionException re) {
			System.err.println("impossible: "+re);
		}
		boolean success = !state.failed;
		input.rewind(start);
		state.backtracking--;
		state.failed=false;
		return success;
	}



	public static final BitSet FOLLOW_statements_in_program68 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_statement_in_statements83 = new BitSet(new long[]{0x0000000004000000L});
	public static final BitSet FOLLOW_SEMICOLON_in_statements87 = new BitSet(new long[]{0x0000000709818200L});
	public static final BitSet FOLLOW_statement_in_statements90 = new BitSet(new long[]{0x0000000004000000L});
	public static final BitSet FOLLOW_EOF_in_statements95 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WRITE_in_statement136 = new BitSet(new long[]{0x0000000000800000L});
	public static final BitSet FOLLOW_OPENPAREN_in_statement139 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_statement142 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_statement144 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WRITE_in_statement152 = new BitSet(new long[]{0x0000000000800000L});
	public static final BitSet FOLLOW_OPENPAREN_in_statement155 = new BitSet(new long[]{0x0000000090C2C000L});
	public static final BitSet FOLLOW_string_in_statement160 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_boolexp_in_statement164 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_statement168 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WRITELN_in_statement175 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_statement195 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_statement197 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_statement200 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_DEF_in_statement209 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_ID_in_statement212 = new BitSet(new long[]{0x0000000000100000L});
	public static final BitSet FOLLOW_LS_in_statement214 = new BitSet(new long[]{0x0000000000020000L});
	public static final BitSet FOLLOW_INTNUM_in_statement217 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_RS_in_statement219 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_in_statement226 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_statement228 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_statement231 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_READ_in_statement237 = new BitSet(new long[]{0x0000000000800000L});
	public static final BitSet FOLLOW_OPENPAREN_in_statement240 = new BitSet(new long[]{0x0000000000008000L});
	public static final BitSet FOLLOW_ID_in_statement243 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_statement245 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_SKIP_in_statement252 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_IF_in_statement258 = new BitSet(new long[]{0x0000000080C2C000L});
	public static final BitSet FOLLOW_boolexp_in_statement261 = new BitSet(new long[]{0x0000000040000000L});
	public static final BitSet FOLLOW_THEN_in_statement263 = new BitSet(new long[]{0x0000000709818200L});
	public static final BitSet FOLLOW_statement_in_statement266 = new BitSet(new long[]{0x0000000000001000L});
	public static final BitSet FOLLOW_ELSE_in_statement268 = new BitSet(new long[]{0x0000000709818200L});
	public static final BitSet FOLLOW_statement_in_statement271 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WHILE_in_statement277 = new BitSet(new long[]{0x0000000080C2C000L});
	public static final BitSet FOLLOW_boolexp_in_statement280 = new BitSet(new long[]{0x0000000000000800L});
	public static final BitSet FOLLOW_DO_in_statement282 = new BitSet(new long[]{0x0000000709818200L});
	public static final BitSet FOLLOW_statement_in_statement285 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OPENPAREN_in_statement291 = new BitSet(new long[]{0x0000000709818200L});
	public static final BitSet FOLLOW_statements_in_statement294 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_statement296 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_array315 = new BitSet(new long[]{0x0000000000100000L});
	public static final BitSet FOLLOW_LS_in_array318 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_array321 = new BitSet(new long[]{0x0000000002000000L});
	public static final BitSet FOLLOW_RS_in_array323 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_boolterm_in_boolexp350 = new BitSet(new long[]{0x0000000000000022L});
	public static final BitSet FOLLOW_AND_in_boolexp353 = new BitSet(new long[]{0x0000000080C2C000L});
	public static final BitSet FOLLOW_boolterm_in_boolexp356 = new BitSet(new long[]{0x0000000000000022L});
	public static final BitSet FOLLOW_NOT_in_boolterm374 = new BitSet(new long[]{0x000000008082C000L});
	public static final BitSet FOLLOW_bool_in_boolterm379 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_TRUE_in_bool394 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_FALSE_in_bool398 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_exp_in_bool414 = new BitSet(new long[]{0x0000000000042000L});
	public static final BitSet FOLLOW_bop_in_bool416 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_bool419 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OPENPAREN_in_bool426 = new BitSet(new long[]{0x0000000080C2C000L});
	public static final BitSet FOLLOW_boolexp_in_bool429 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_bool431 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_term_in_exp478 = new BitSet(new long[]{0x0000000020000012L});
	public static final BitSet FOLLOW_set_in_exp482 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_term_in_exp493 = new BitSet(new long[]{0x0000000020000012L});
	public static final BitSet FOLLOW_factor_in_term511 = new BitSet(new long[]{0x0000000000200002L});
	public static final BitSet FOLLOW_MUL_in_term515 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_factor_in_term518 = new BitSet(new long[]{0x0000000000200002L});
	public static final BitSet FOLLOW_ID_in_factor538 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_INTNUM_in_factor546 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_array_in_factor552 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_OPENPAREN_in_factor558 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_factor561 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_factor563 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_STRING_in_string583 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_WRITE_in_synpred1_Syn121 = new BitSet(new long[]{0x0000000000800000L});
	public static final BitSet FOLLOW_OPENPAREN_in_synpred1_Syn124 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_synpred1_Syn127 = new BitSet(new long[]{0x0000000000000080L});
	public static final BitSet FOLLOW_CLOSEPAREN_in_synpred1_Syn129 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_ID_in_synpred2_Syn182 = new BitSet(new long[]{0x0000000000000040L});
	public static final BitSet FOLLOW_ASSIGN_in_synpred2_Syn184 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_synpred2_Syn187 = new BitSet(new long[]{0x0000000000000002L});
	public static final BitSet FOLLOW_exp_in_synpred3_Syn405 = new BitSet(new long[]{0x0000000000042000L});
	public static final BitSet FOLLOW_bop_in_synpred3_Syn407 = new BitSet(new long[]{0x0000000000828000L});
	public static final BitSet FOLLOW_exp_in_synpred3_Syn410 = new BitSet(new long[]{0x0000000000000002L});
}
